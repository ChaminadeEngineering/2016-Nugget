// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

#include "Pivot.h"
#include "../RobotMap.h"
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

Pivot::Pivot() : Subsystem("Pivot")
{
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    pivotMotor = RobotMap::pivotpivotMotor;
    pivotLowerLimit = RobotMap::pivotPivotLowerLimit;
    pivotEncoder = RobotMap::pivotPivotEncoder;
    pivotUpperLimit = RobotMap::pivotPivotUpperLimit;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS


}

void Pivot::InitDefaultCommand()
{
    // Set the default command for a subsystem here.
    // SetDefaultCommand(new MySpecialCommand());
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

	Pivot::pivotMotor->SetInverted(true) ;
}

// Put methods for controlling this subsystem
// here. Call these from Commands.


//TODO get the actual encoder values -- write code for live window
void Pivot::GetEncoderValue() //Gets encoder value for nextTarget
{
	pivotEncoder->Get(); //retrieves encoder value
}

void Pivot::MovePivotUp() // Moves pivot up in the direction of the Shooting Position or position 4
{

	GetEncoderValue() ;

	/*DON'T MOVE*/
	if(pivotUpperLimit->Get() == 1) // If the limit switch is pressed then the variable is -1
		{
			nextTarget = -1 ;
			StopPivot() ; //do nothing! At highest point
		}

		else if(pivotEncoder->Get() >= SetPoint4)// if the pivot encoder is at position 4 the variable is at -1
		{
			nextTarget = -1 ;
			StopPivot() ; //do nothing! At highest point
		}
	/*DON'T MOVE*/

	/*MOVE TO SETPOINT 4*/
		else if(pivotEncoder->Get() >= SetPoint3)//if the encoder is at position 3 then the variable is at setpoint 4
		{
			nextTarget = SetPoint4 ;

			while(pivotEncoder->Get() < nextTarget) //while the encoder is less than nextTarget(SetPoint4) keep the motor moving
			{
				pivotMotor->Set(.33) ;
			}

			StopPivot() ; //Once its <= nextTarget Stop the motor
		}
	/*MOVE TO SETPOINT 4*/

	/*MOVE TO SETPOINT 3*/
		else if(pivotEncoder->Get() >= SetPoint2) // if the encoder is at position 2 then the variable is at setpoint 3
		{
			nextTarget = SetPoint3 ;

			while(pivotEncoder->Get() < nextTarget) //While the pivot encoder is less than the nextTarget(SetPoint3) keep the motor going
			{
				pivotMotor->Set(.33) ;
			}

			StopPivot() ; //Once its <= nextTarget Stop the motor
		}
	/*MOVE TO SETPOINT 3*/

	/*MOVE TO SETPOINT 2*/
		else if(pivotEncoder->Get() >= SetPoint1) //If the pivot encoder is at position 1 then the variable is at setpoint 2
		{
			nextTarget = SetPoint2 ;

			while(pivotEncoder->Get() < nextTarget) //While the pivot encoder is < the nextTarget keep the motor going
			{
				pivotMotor->Set(.33) ;
			}

			StopPivot() ; //Once its <= nextTarget Stop the motor
		}
	/*MOVE TO SETPOINT 2*/

	/*MOVE TO SETPOINT 1*/
		else if(pivotEncoder->Get() >= SetPoint0) // if the pivot encoder is at position 0 then the variable is at setpoint 1
		{
			nextTarget = SetPoint1 ;

			while(pivotEncoder->Get() < nextTarget)//While the pivot encoder is < the nextTarget position keep the motor going
			{
				pivotMotor->Set(.33) ;
			}

			StopPivot() ; //Once its <= nextTarget Stop the motor
		}

		else if (pivotLowerLimit->Get() == 1)//if the lower limit switch is pressed then the next target is 1
		{
			nextTarget = SetPoint1 ;
			pivotEncoder->Reset() ;

			while(pivotEncoder->Get() < nextTarget)
			{
				pivotMotor->Set(.33) ;
			}

			StopPivot() ; //Once its <= nextTarget Stop the motor
		}
	/*MOVE TO SETPOINT 1*/
}

void Pivot::MovePivotDown() //Moves pivot down in he direction of the collecting position or position 0
{

	GetEncoderValue() ;

	/*DON'T MOVE*/
	if(pivotLowerLimit->Get() == 1)
	{
		nextTarget = -1 ;
		pivotEncoder->Reset() ;

		StopPivot() ; //do nothing! At lowest point
	}

	else if(pivotEncoder->Get() <= SetPoint0)
	{
		nextTarget = -1 ;
		StopPivot() ; //do nothing! At lowest point
	}
	/*DON'T MOVE*/

	/*MOVE TO SETPOINT 0*/
	else if(pivotEncoder->Get() <= SetPoint1) //If the encoder is at SetPoint1 then move down to SetPoint0
	{
		nextTarget = SetPoint0 ;

		while(pivotEncoder->Get() > nextTarget) //While it is > nextTarget then move the motor backwards
		{
			pivotMotor->Set(-.33);
		}

		StopPivot() ; //Once its <= nextTarget Stop the motor
	}
	/*MOVE TO SETPOINT 0*/

	/*MOVE TO SETPOINT 1*/
	else if(pivotEncoder->Get() <= SetPoint2) //If the encoder value is <= to SetPoint2 then move down to SetPoint1
	{
		nextTarget = SetPoint1 ;

		while(pivotEncoder->Get() > nextTarget) //WHile the encoder is > nextTarget then move the motor backwards
		{
			pivotMotor->Set(-.33) ;
		}

		StopPivot() ; //Once its <= nextTarget Stop the motor
	}
	/*MOVE TO SETPOINT 1*/

	/*MOVE TO SETPOINT 2*/
	else if(pivotEncoder->Get() <= SetPoint3) //If the encoder value is <= to SetPoint3 then move down to SetPoint2
	{
		nextTarget = SetPoint2 ;

		while(pivotEncoder->Get() > nextTarget) //WHile the encoder is > nextTarget then move the motor backwards
		{
			pivotMotor->Set(-.33) ;
		}

		StopPivot() ; //Once its <= nextTarget Stop the motor
	}
	/*MOVE TO SETPOINT 2*/

	/*MOVE TO SETPOINT 3*/
	else if(pivotEncoder->Get() <= SetPoint4)//If the encoder value is <= to SetPoint4 then move down to SetPoint3
	{
		nextTarget = SetPoint3 ;

		while(pivotEncoder->Get() > nextTarget) //While the encoder is > nextTarget then move the motor backwards
		{
			pivotMotor->Set(-.33) ;
		}

		StopPivot() ; //Once its <= nextTarget Stop the motor
	}

	else if(pivotUpperLimit->Get() == 1) //If the UpperLimit is pressed then nextTarget is SetPoint3
	{
		nextTarget = SetPoint3 ;

		while(pivotEncoder->Get() > nextTarget) //While the encoder is > nextTarget then move the motor backwards
		{
			pivotMotor->Set(-.33) ;
		}

		StopPivot() ; //Once its <= nextTarget Stop the motor
	}
	/*MOVE TO SETPOINT 3*/


}

void Pivot::StopPivot()
{

	pivotMotor->Set(0);

}

